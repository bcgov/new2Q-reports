# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FNBLine
                                 A QGIS plugin
 This plugin takes an area of interest and produces a PDF outlining overlapping layers
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-08-09
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Evan Lavine 
        email                : evan.lavine@bc.gov.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import *

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import (QAction, QFileDialog)
from qgis.gui import QgsMessageBar
from qgis.utils import iface

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .FN_BLine_dialog import FNBLineDialog
import os.path
#import other modules for run module to operate 
import csv
import requests
import json
import time
import processing
import sys
import re
from configparser import ConfigParser
from PyQt5.QtCore import *
from PyQt5.QtGui import *

def config(filename, section):
    # create a parser
    parser = ConfigParser()
    # read config file
    parser.read(filename)
    db = {}
    if parser.has_section(section):
        params = parser.items(section)
        for param in params:
            db[param[0]] = param[1]
    else:
        raise Exception(
            'Section {0} not found in the {1} file'.format(section, filename))
    return db

def external_intersetion(location, layer_table, name, overlay, o2q_obj):
    layer_path = r'{}'.format(location) + '|layername=' + layer_table
    result = o2q_obj.clipper(layer_path, overlay, name, selection=True)
    return result

def parse_csv(csv_path):
    dictionary = {}
    with open(csv_path, mode='r') as csv_file:
        csv_reader = csv.reader(csv_file)
        next(csv_reader, None)
        for row in csv_reader:
            dictionary[row[0]] = {"Feature_Name": row[1], "Location": row[2], "Queries": row[3], "Grouping":row[4], "Expansion":row[5]}
    return dictionary

def choose_vis(group_num, group_dic):
    on = group_dic['g{}'.format(group_num)]
    off = []
    for item in group_dic:
        if item != 'g{}'.format(group_num):
            for fc in group_dic[item]:
                off.append(fc)
    return (on, off)

def build_extent(layer):
        rectangle = QgsVectorLayer.extent(layer)
        rect = [rectangle.xMinimum(), rectangle.yMinimum(), rectangle.xMaximum(), rectangle.yMaximum()]
        X_per_ext = (rect[2] - rect[0])*0.05
        Y_per_ext = (rect[3] - rect[1])*0.05
        ext = [(rect[0] - X_per_ext), (rect[1] - Y_per_ext), (rect[2] + X_per_ext), (rect[3] + Y_per_ext)]
        exnt = QgsRectangle(ext[0], ext[1], ext[2], ext[3])
        return exnt

def summation(layer, name, field='layer', special=False):   
    dic = {} 
    dic_ls = []
    features = layer.getFeatures()
    for feat in features:
        if ',' in field:
            field_edit = re.sub(' +', '', field)
            field_edit = field_edit.split(',')
            field_name = feat.attribute(field_edit[0])
        else:
            field_name = feat.attribute(field)
            dic_ls.append(field_name) # builds a list so that a count can happen for each unique attribute
        if ',' in field:
            rec_count = 0
            for rec in field_edit:
                if rec_count != 0:
                    if feat.attribute(field_edit[rec_count]) != ' ':
                        field_name = field_name + ' and ' + feat.attribute(field_edit[rec_count])
                rec_count += 1
            dic_ls.append(field_name)
        if field_name not in dic: # adds field attribute to dictionary if it doesnt exist yet as well as the features area/length
            dic[field_name] = [] 
            dic[field_name].append(feat.geometry().area())
            dic[field_name].append(feat.geometry().length())
        else:
            dic[field_name] = [dic[field_name][0] + feat.geometry().area(), dic[field_name][1] + feat.geometry().length()]           
    if special is False:
        area = dic[name][0]
        length = dic[name][1]
        if area and length == 0:
            return ('N/A', 'N/A')
        elif length != 0 and area == 0:
            return ('length', int(length))
        else:
            return ('area', int(area))
    elif special == 'aoi':
        area = dic[name][0]
        length = dic[name][1]
        return (int(area), int(length))
    else:
        return (dic, dic_ls)



class pdf_maker_QGIS:
    def __init__(self):
        self.project = QgsProject.instance()
        self.tc_root = self.project.layerTreeRoot()
        self.width = 216
        self.height = 280
        self.left_m = 10
        self.top_m = 30
        self.bot_m = 30
        refSize = self.width
    def __html_maker(self, table_html):
        if self.sum_type == 'area':
            area = self.sum_num
            length = 'N/A'
        elif self.sum_type == 'length':
            area = 'N/A'
            length = self.sum_num
        elif isinstance(self.sum_type, int):
            area = self.sum_type
            length = self.sum_num
        else:
            area = 'N/A'
            length = 'N/A'
        if table_html in ["None", "blank_html"]:
            table_html = '<!DOCTYPE html><html><head><style>h2{line-height:0px }table {border: 2.5px solid black;table-layout: fixed; width:100%;}th, td {padding: 5px; word-wrap: break-word; border: 1px solid black;}</style></head><body><h2>Intersecting Features</h2><table><tr><th>Feature Name</th><th>Area Sq.Metres</th><th>Length Metres</th><th>Count</th></tr>      </table></body></html>'
        text1,text2 = table_html.split('      ')
        row ='<tr><td>{}</td><td>{}</td><td>{}</td><td>{}</td></tr>'.format(self.layer_title, area, length, self.count)
        self.text_table[self.layer_title] = [area, length, self.count]
        table_html = text1 + row + '      ' + text2
        return table_html
    def html_combiner(self, html_dic, html_counter, sum_type, sum_num, gkey, layer_title, count, text_table):
        self.sum_type = sum_type
        self.sum_num = sum_num
        self.group_key = 'g' + str(gkey)
        self.layer_title  = layer_title
        self.count = count
        self.text_table = text_table
        rpp = 15 #rows per page
        pg_num = int(list(html_dic[self.group_key].keys())[-1].strip('pg'))
        pg_key = 'pg{}'.format(pg_num)
        new_pg_key = 'pg{}'.format(pg_num + 1)
        if html_counter == rpp*(pg_num):
            self.html_code = self.__html_maker("blank_html")
            html_dic[self.group_key][new_pg_key] = self.html_code
        else:
            self.html_code = self.__html_maker(html_dic[self.group_key][pg_key])
            if html_counter < rpp: #table goes to pg1 of group table if count is low
                html_dic[self.group_key]['pg1'] = self.html_code
            if (rpp*(pg_num-1)) < html_counter < (rpp*(pg_num)): #table goes to next page 
                html_dic[self.group_key][pg_key] = self.html_code
    # pdf_creation designs and exports a pdf based on predetermined settings
        # INPUTS    aoi = the qgis vector layer used as the area of interest
        #           aoi_e = the qgis vector layer used as the area of interest less any intersections
        #           html_table = a list of html based tables that are added to each page
    def pdf_creation(self, AOI, file_name, html_table, pdf_path):
        self.lmg = self.project.layoutManager()
        self.l = QgsPrintLayout(self.project)
        self.l.initializeDefaults()
        self.l.setUnits(QgsUnitTypes.LayoutMillimeters)
        self.lmg.clear()
        page = self.l.pageCollection().pages()[0]
        page.setPageSize(QgsLayoutSize(self.width, self.height))
        #self.l.pageCollection().resizeToContents(QgsMargins().fromString('10') , QgsUnitTypes.LayoutMillimeters)
        self.__map(AOI)
        self.__title()
        self.__subtitle(AOI)
        self.__logo()
        self.__date()
        self.__scalebar()
        self.__referenceInfo(AOI)
        self.__table(html_table)
        self.__legend(AOI)
        self.__export(file_name, pdf_path)
    def __map(self, AOI):
        # add map
        self.frame_w = self.width -  2 * self.left_m
        self.frame_h = self.height - 120
        theMap = QgsLayoutItemMap(self.l)
        self.theMap = theMap
        theMap.updateBoundingRect()
        theMap.setRect(QRectF(self.left_m, self.top_m - 5, self.frame_w, self.frame_h))
        theMap.setPos(self.left_m, self.top_m - 5)
        theMap.setFrameEnabled(True)
        exnt = build_extent(AOI)
        theMap.setLayers(self.project.mapThemeCollection().masterVisibleLayers())
        #theMap.setLayers(list_on)
        theMap.setExtent(exnt)
        theMap.attemptMove(QgsLayoutPoint(self.left_m, self.top_m - 5))
        theMap.attemptResize(QgsLayoutSize(self.frame_w, self.frame_h))
        theMap.zoomToExtent(exnt)
        self.l.addItem(theMap)
    def __title(self):
        titleFont = QFont("Arial", 26)
        titleFont.setBold(True)
        titelLabel = QgsLayoutItemLabel(self.l)
        titelLabel.setText('First Nations Business Line Area of Interest')
        titelLabel.setPos(self.left_m / 2 , self.top_m / 6)
        titelLabel.setFont(titleFont)
        titelLabel.adjustSizeToText()
        self.l.addItem(titelLabel)
    def __subtitle(self, AOI):
        subTitleFont = QFont("Arial", 11)
        subTitleFont.setBold(False)
        subTitelLabel = QgsLayoutItemLabel(self.l)
        subt = AOI.name()
        subTitelLabel.setText(subt)
        subTitelLabel.setPos(self.left_m, self.top_m / 2 + 3)
        subTitelLabel.setFont(subTitleFont)
        subTitelLabel.adjustSizeToText()
        self.l.addItem(subTitelLabel)
    def __logo(self):
        logoImagePath = #~~~~~~~~~~~~~~~~~INSERT LOGO PATH HERE ~~~~~~~~~~~~~~~~~~~~~~~
        logo = QgsLayoutItemPicture(self.l)
        logo.setPicturePath(logoImagePath)
        logo.attemptSetSceneRect(QRectF(170, 202, 35, 15))
        self.l.addItem(logo)
    def __date(self):
        dateLabel = QgsLayoutItemLabel(self.l)
        d = time.localtime()
        dString = "%d-%d-%d" % (d[2],  d[1],  d[0])
        dateLabel.setText('Date: ' + dString)
        dateLabel.setFont(QFont("Arial", 10))
        dateLabel.adjustSizeToText()
        dateStringWidth = dateLabel.sizeForText().width()
        dateLabel.setPos(self.width -2 - self.left_m - dateStringWidth, 196)
        self.l.addItem(dateLabel)
    def __scalebar(self):
        scaleBar = QgsLayoutItemScaleBar(self.l)
        scaleBar.setLinkedMap(self.theMap)
        scaleBar.applyDefaultSettings()
        scaleBar.applyDefaultSize()
        scaleBar.setNumberOfSegmentsLeft(0)
        scaleBar.setNumberOfSegments (5)
        scaleBar.update()
        scaleBar.setPos(self.left_m, self.height - 90 )
        self.l.addItem(scaleBar)
    def __referenceInfo(self, AOI):
        map_info = QgsLayoutItemLabel(self.l)
        crs = AOI.crs()
        infotext = "Projection: {}".format(crs.description())
        map_info.setText(infotext)
        map_info.setFont(QFont("Arial", 10))
        map_info.adjustSizeToText()
        map_infoStringWidth = map_info.sizeForText().width()
        map_info.setPos(self.width -2 - self.left_m - map_infoStringWidth, self.height - 90)
        self.l.addItem(map_info)
    def __legend(self, AOI):
        legend = QgsLayoutItemLegend(self.l)
        newFont = QFont("Arial", 6)
        legend.setStyleFont(QgsLegendStyle.SymbolLabel, newFont)
        legend.setAutoUpdateModel(True)
        legend.updateFilterByMap(True)
        legend.setTitle("Legend")
        legend.setColumnCount(4)
        legend.setColumnSpace(5)
        legend.setSymbolHeight(2)
        legend.setSymbolWidth(3.5)
        legend.setPos(self.left_m , 212)
        legend.setBoxSpace(0)
        # legend.setSplitLayer(True)
        # legend.setWrapString(' ')
        # pgcnt = len(self.l.pageCollection().pages()) - 1
        # legend.setPos(self.left_m , self.height*pgcnt + self.top_m )
        self.l.addItem(legend)
    def __table(self,html_table):
        if isinstance(html_table,dict) is True:
        #add table to multiple pages
            for item in html_table:
                self.l.pageCollection().extendByNewPage()
                tbl = QgsLayoutItemLabel(self.l)
                tbl.setFont(QFont("Arial", 10))
                tbl.adjustSizeToText()
                tbl.setMode(QgsLayoutItemLabel.ModeHtml)
                t1 = html_table[item]
                tbl.setText(t1)
                pgcnt = len(self.l.pageCollection().pages()) - 1
                tbl.attemptResize(QgsLayoutSize(self.width - 2*self.left_m, self.height - 2*self.top_m))
                tbl.attemptMove(QgsLayoutPoint(self.left_m , self.height*pgcnt + self.top_m ))
                self.l.addItem(tbl)
    def __export(self, file_name, pdf_path):
        exporter =  QgsLayoutExporter(self.l)
        pdf_settings = exporter.PdfExportSettings()
        path = pdf_path + '\\' + 'FnBline{}.pdf'.format(file_name)
        exporter.exportToPdf(path, pdf_settings)
    def png_creation(self, AOI, img_path):
        self.__map(AOI)
        self.__title()
        self.__subtitle(AOI)
        self.__logo()
        self.__date()
        self.__scalebar()
        self.__referenceInfo(AOI)
        self.__table(html_table)
        # export pdf
        exporter =  QgsLayoutExporter(self.l)
        img_settings = exporter.ImageExportSettings()
        img_settings.dpi = 300
        img_settings.imageSize = QSize(2000, 2160)
        res = exporter.exportToImage(img_path, img_settings)

class o2q:
    # INIT METHOD: sets up the oracle database connection and Qgis instance
    def __init__(self, database, host, user, port, password):
        self.project = QgsProject.instance()
        self.tc_root = self.project.layerTreeRoot()
        self.db = database
        self.host = host
        self.port = port
        self.user = user
        self.password = password
        search = ["https://catalogue.data.gov.bc.ca/api/3/action/package_search?q=WHSE_&rows=1000&start=0", "https://catalogue.data.gov.bc.ca/api/3/action/package_search?q=REG_&rows=1000&start=0"]
        self.d = {}
        for item in search:
                r = requests.get(item)
                f = r.json()
                records = f['result']['results']
                for r in records:
                        if 'object_name' in r.keys() and 'details' in r.keys():
                                #if (r['object_name']) == 'WHSE_ARCHAEOLOGY.RAAD_TFM_SITE':
                                detail_list = r['details']
                                length_colm = ''
                                area_colm = ''
                                geom_type = 'Point'
                                for dic in sorted(detail_list, key = lambda k:k['column_name'], reverse=True):
                                        if dic['data_type'] == 'SDO_GEOMETRY':
                                                geom_colm = dic['column_name']
                                        if 'column_comments' in dic:
                                                if "system calculated area" in dic['column_comments']:
                                                        area_colm = dic['column_name']
                                                        geom_type = 'Polygon'
                                                if "system calculated length" in dic['column_comments']:
                                                        length_colm = dic['column_name']
                                                        geom_type = 'LineString'
                                        else:
                                                if "area" in dic['column_name'].lower():
                                                        area_colm = dic['column_name']
                                                        geom_type = 'Polygon'
                                                if "length" in dic['column_name'].lower():
                                                        length_colm = dic['column_name']
                                                        geom_type = 'LineString'
                                self.d[r['object_name']] = {"Title": r['title'], "Geometry": geom_colm, 'Type': geom_type}
        #setup basemap
        urlWithParams = #~~~~~~~~~~~~~~~~INSERT URL TO BASEMAP WMS HERE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        rlayer = QgsRasterLayer(urlWithParams, '', 'wms')
        self.project.addMapLayer(rlayer)
        self.tc_root.findLayer(rlayer).setItemVisibilityChecked(True)
    # SELECT_BY_ATTRIBUTE METHOD: returns a qgis vector layer using an sql query on a single dataset
        # INPUTS:   data = schema.table
        #           datawc = sql statment ie fieldname = 'value'
    def select_by_attribute(self, data, datawc):
        if datawc != '':
            datawc = ' where ' + datawc
        sql = "(select * from {}  {} )".format(data, datawc)
        return self.__build_layer(data, sql)
    # SELECT_BY_LOCATION METHOD: returns a QGIS vector layer by defining the type of overlay and calls the method for building the overlay
        # INPUTS:   data1/2 = schema.table
        #           datawc = sql statment ie fieldname = 'value'
        #           overlay_type = 'Completely Within' or 'Intersect'
    def select_by_location(self, data1, data2, data1wc, data2wc, overlay_type, name):
        self.layer_title = name
        if overlay_type == 'Intersect':
            return self.__anyinteract(data1, data2, data1wc, data2wc)
    # __ANYINTERACT METHOD: internal method that returns an sql statement based on an oracle SDO_RELATE spatial operation
    #                       ANYINTERACT selects features from DATA1 that intersect the defined features of DATA2
        # INPUTS:   data1 = Feature being selected (schema.table)
        #           data2 = Features defining the selection (schema.table)
        #           datawc = sql statment ie fieldname = 'value'
    def __anyinteract(self, data1, data2, data1wc, data2wc):
        data1wc = self.__whereclauses(data1wc, '1')
        data2wc = self.__whereclauses(data2wc, 'aoi')
        if data1 in ['WHSE_ARCHAEOLOGY.RAAD_TFM_SITES_SVW', 'WHSE_ARCHAEOLOGY.RAAD_AOA_PROVINCIAL','WHSE_TERRESTRIAL_ECOLOGY.BIOT_OCCR_MASKED_SENS_PRIV_SP', 'WHSE_WILDLIFE_MANAGEMENT.WCP_CRITICAL_HABITAT_SECURE_SP']:
            if data1 in ['WHSE_TERRESTRIAL_ECOLOGY.BIOT_OCCR_MASKED_SENS_PRIV_SP',  'WHSE_ARCHAEOLOGY.RAAD_AOA_PROVINCIAL']:
                sql = "(select * from {0}  where {4} sdo_ANYINTERACT({2},  (select {3}  from {1} {5})) = 'TRUE')".format(data1, data2, 'GEOMETRY' , self.__get_geomcolumn(data2), data1wc, data2wc)
            else:
                sql = "(select * from {0}  where {4} sdo_ANYINTERACT({2},  (select {3}  from {1} {5})) = 'TRUE')".format(data1, data2, 'SHAPE' , self.__get_geomcolumn(data2), data1wc, data2wc)
        else:
            sql = "(select * from {0}  where {4} sdo_ANYINTERACT({2},  (select {3}  from {1} {5})) = 'TRUE')".format(data1, data2, self.__get_geomcolumn(data1) , self.__get_geomcolumn(data2), data1wc, data2wc)
            #sql = "(select b.* from {0} b, {1} aoi where  {4}  {5}  SDO_RELATE(b.{2}, aoi.{3}, 'mask=anyinteract querytype=window') = 'TRUE')".format(data1, data2, self.__get_geomcolumn(data1) , self.__get_geomcolumn(data2), data1wc, data2wc)
        return self.__build_layer(data1, sql)
    # RECT_ANYINTERACT METHOD: method defines an aoi by a given extent and returns a QGIS vector layer of intersecting table
    # INPUTS:   data1 = feature being selected (schema.table)
    #           feat = single feature that an extent string will be generated from
    def Rect_anyinteract(self, data1, feat, name):
        self.layer_title = name
        exnt_str = self.extent_rectangle(feat)
        if data1 in ['WHSE_ARCHAEOLOGY.RAAD_TFM_SITES_SVW', 'WHSE_ARCHAEOLOGY.RAAD_AOA_PROVINCIAL', 'WHSE_TERRESTRIAL_ECOLOGY.BIOT_OCCR_MASKED_SENS_PRIV_SP', 'WHSE_WILDLIFE_MANAGEMENT.WCP_CRITICAL_HABITAT_SECURE_SP']:
            if data1 in ['WHSE_TERRESTRIAL_ECOLOGY.BIOT_OCCR_MASKED_SENS_PRIV_SP', 'WHSE_ARCHAEOLOGY.RAAD_AOA_PROVINCIAL']:
                sql = "(select * from {} where sdo_ANYINTERACT ({}, SDO_GEOMETRY(2003, 3005, NULL,SDO_ELEM_INFO_ARRAY(1,1003,3),SDO_ORDINATE_ARRAY({}))) = 'TRUE')".format(data1, 'GEOMETRY', exnt_str)
            else:
                sql = "(select * from {} where sdo_ANYINTERACT ({}, SDO_GEOMETRY(2003, 3005, NULL,SDO_ELEM_INFO_ARRAY(1,1003,3),SDO_ORDINATE_ARRAY({}))) = 'TRUE')".format(data1, 'SHAPE', exnt_str)
        else:
            sql = "(select * from {} where sdo_ANYINTERACT ({}, SDO_GEOMETRY(2003, 3005, NULL,SDO_ELEM_INFO_ARRAY(1,1003,3),SDO_ORDINATE_ARRAY({}))) = 'TRUE')".format(data1, self.__get_geomcolumn(data1), exnt_str)
        return self.__build_layer(data1, sql)
    # __WHERECLAUSES METHOD: internal method that returns a transformed whereclauses
    # INPUTS:   datawc = sql statment ie fieldname = 'value'
    def __whereclauses(self, datawc, placement):
        if datawc != '' and placement == '1':
            datawc = datawc + ' and '
            #for SDO.RELATE: datawc = ' b.' + datawc + ' and '
        if datawc != '' and placement == 'aoi':
            datawc = ' where ' + datawc
            #for SDO.RELATE: datawc = ' aoi.' + datawc + ' and '
        return datawc
    # __BUILD_LAYER METHOD: internal method that returns a built QGIS vector layer
    #                       NOTE: Method assumes paramaters based on BCGW datasets
        # INPUTS:   data1 = schema.table
        #           sql = sql statements that were formed in any of the above methods
    def __build_layer(self, data1, sql):
        uri = QgsDataSourceUri()
        uri.setConnection(self.host, self.port, self.db, self.user, self.password)
        uri.setDriver('oracle')
        uri.setSrid('3005')
        uri.setUseEstimatedMetadata(True)
        uri.setKeyColumn('OBJECTID')
        if data1 in ['WHSE_ARCHAEOLOGY.RAAD_TFM_SITES_SVW', 'WHSE_ARCHAEOLOGY.RAAD_AOA_PROVINCIAL', 'WHSE_TERRESTRIAL_ECOLOGY.BIOT_OCCR_MASKED_SENS_PRIV_SP', 'WHSE_WILDLIFE_MANAGEMENT.WCP_CRITICAL_HABITAT_SECURE_SP']:
            if data1 in ['WHSE_TERRESTRIAL_ECOLOGY.BIOT_OCCR_MASKED_SENS_PRIV_SP', 'WHSE_ARCHAEOLOGY.RAAD_AOA_PROVINCIAL']:
                uri.setDataSource( "", sql, 'GEOMETRY', "", "OBJECTID")
                uri.setWkbType(QgsWkbTypes.Polygon)
            else:
                uri.setDataSource( "", sql, 'SHAPE', "", "OBJECTID")
                uri.setWkbType(QgsWkbTypes.Polygon)
        else:
            uri.setDataSource( "", sql, self.__get_geomcolumn(data1), "", "OBJECTID")
            uri.setWkbType(int('{}'.format(getattr(QgsWkbTypes, self.__get_geomtype(data1)))))
        n_layer = QgsVectorLayer(uri.uri(), self.layer_title, 'oracle')
        n_layer.setCrs(QgsCoordinateReferenceSystem(3005),True)
        return n_layer
    # __GET_GEOMTYPE METHOD: internal method that determines the geometry type of a dataset ie Polygon, Point, LineString
        # INPUTS:   data = schema.table
    def __get_geomtype(self, data):
        self.geom_t = self.d[data]['Type']
        return self.geom_t
    # __GET_GEOMCOLUMN METHOD: internal method that determines the geometry column of a dataset ie SHAPE, GEOMETRY
        # INPUTS:   data = schema.table
    def __get_geomcolumn(self, data):
        self.geom_c = self.d[data]['Geometry']
        return self.geom_c
    # __GET_LAYERNM METHOD: internal method that determines an appropriate vector layer name
        # INPUTS:   data = schema.table
    def get_layernm(self, data):
        self.geom_nm = self.d[data]['Title']
        return self.geom_nm
    # DIFFERENCE METHOD: a qgis vector overlay process which returns an earased QGIS Vector layer
        # INPUTS:   layer1 = a vector layer being erased
        #           layer2 = the overlay vector layer used to erase layer1
    def difference(self, layer1, layer2):
        d_layer = (processing.run("native:difference", {'INPUT':layer1,'OVERLAY':layer2,'OUTPUT':'memory:{}'.format('50m Buffer')})).get('OUTPUT')
        self.project.addMapLayer(d_layer)
        return d_layer
    # BUFFER METHOD: a qgis vector geoprocess which returns a buffered area of a QGIS Vector layer
        # INPUTS:   layer1 = vector layer being buffered
    def buffer(self, layer1, meters):
        b_layer = (processing.run("native:buffer", {'INPUT':layer1,'DISTANCE':meters,'SEGMENTS':5,'END_CAP_STYLE':0,'JOIN_STYLE':0,'MITER_LIMIT':2,'DISSOLVE':False,'OUTPUT':'memory:'})).get('OUTPUT')
        return b_layer
    # CLIPPER METHOD: a qgis vector overlay process which returns a clipped QGIS Vector layer
        # INPUTS:   layer1 = a vector layer being clipped
        #           layer2 = the overlay vector layer used to clip layer1
        #           selection = when false, clipping will happen between 2 unselected layers. When true, overlay must have selection for clip to work
    def clipper(self, layer1, layer2, name, selection=False):
        c_layer = (processing.run("native:clip", {'INPUT':layer1, 'OVERLAY': QgsProcessingFeatureSourceDefinition(layer2.name(), selection), 'OUTPUT':'memory:{}'.format(name)})).get('OUTPUT')
        c_layer.setCrs(QgsCoordinateReferenceSystem(3005),True)
        return c_layer
    # __FIX_GEOMETRY METHOD: a qgis vector overlay process which returns a clipped QGIS Vector layer
        # INPUTS:   layer1 = a vector layer being fixed
    def fix_geom(self, layer1, name):
        fg_layer = (processing.run("native:fixgeometries", {'INPUT':layer1,'OUTPUT':'memory:{}'.format(name)})).get('OUTPUT')
        fg_layer.setCrs(QgsCoordinateReferenceSystem(3005),True)
        return fg_layer
    # MERGER METHOD: a qgis vector data management process which returns a compilation of QGIS Vector layers as a single vector layer
        # INPUTS:   list_of_layers = a list of vector layers that will be merged together
    def merger(self, list_of_layers, name, crs='EPSG:3005'):
        m_layer = (processing.run("native:mergevectorlayers", {'LAYERS':list_of_layers, 'CRS':QgsCoordinateReferenceSystem(crs),'OUTPUT':'memory:{}'.format(name)})).get('OUTPUT')
        m_layer.setCrs(QgsCoordinateReferenceSystem(3005),True)
        return m_layer
    # __LISTFIELDS METHOD: internal method that returns a list of all the fields in a layer except for 'SE_ANNO_CAD_DATA'
        # INPUTS:   oracle_source = can either be a QGIS vector layer or a schema.table from BCGW
    def __listFields(self, oracle_source):
        try:
            oracle_source.isValid()
            flist = [f.name() for f in oracle_source.fields()]
            flist.remove('SE_ANNO_CAD_DATA')
        except:
            uri = QgsDataSourceUri()
            uri.setConnection(self.host, self.port,self.db, self.user, self.password)
            schema, table = oracle_source.split('.')
            uri.setDataSource(schema, table, self.__get_geomcolumn(oracle_source))
            uri.setSrid('3005')
            if oracle_source == 'WHSE_FOREST_VEGETATION.VEG_COMP_LYR_R1_POLY':
                uri.setKeyColumn('OBJECT_ID')
            else:
                uri.setKeyColumn('OBJECTID')
            uri.setUseEstimatedMetadata(True)
            #make the layer
            vlayer = QgsVectorLayer(uri.uri(), 'temp_layer', 'oracle')
            assert vlayer.isValid()
            flist = [f.name() for f in vlayer.fields()]
            flist.remove('SE_ANNO_CAD_DATA')
        return flist
    # REPROJECT METHOD: changes the coordinate system used in the QGIS Vector layer
        # INPUTS:   layer1 = a QGIS vector layer
        #           title = the output title
        #           coor = the coordinate system that the layer is being reprojected to
    def reproject(self, layer1, title, coor = 'EPSG:3005'):
        r_layer = (processing.run('native:reprojectlayer', {'INPUT': layer1, 'TARGET_CRS': '{}'.format(coor), 'OUTPUT': 'memory:{}'.format(title)})).get('OUTPUT')
        return r_layer
    # FORMAT_CHECKER METHOD: Tests what type of file is being inputted and produces a vector layer for either shp, kml, FGDB\FC, Oracle Table
        # INPUTS:   input_file = a path of a file or a schema.table name
        #           whcls = a query builder for a QGIS vector layer
    def format_checker(self, input_file, whcls):
        if isinstance(input_file, QgsVectorLayer):
            vlayer = self.reproject(input_file, input_file.name())
            vlayer = self.fix_geom(vlayer, input_file.name())
            self.project.removeMapLayers([input_file.id()])
            self.project.addMapLayer(vlayer)
            vlayer.setSubsetString(whcls)
            return ('external', vlayer)
        elif input_file[-4:] in ['.shp', '.kml', '.kmz'] or '.gdb|' in input_file:
            if '.gdb|' in input_file:
                layer_title = input_file.split('layername=')[-1]
            else:
                if '\\' in input_file:
                    layer_title = (input_file.split('\\'))[-1][0:-4]
                if '/' in input_file:
                    layer_title = (input_file.split('/'))[-1][0:-4]
            vlayer = QgsVectorLayer(input_file, layer_title, "ogr")
            vlayer = self.reproject(vlayer, layer_title)
            vlayer = self.fix_geom(vlayer, layer_title)
            self.project.addMapLayer(vlayer)
            vlayer.setSubsetString(whcls)
            return ('external', vlayer)
        else:
            self.layer_title = self.get_layernm(input_file) + ' where ' + whcls.strip("'")
            vlayer = self.select_by_attribute(input_file, whcls)
            vlayer = self.fix_geom(vlayer, self.layer_title)
            vlayer.setCrs(QgsCoordinateReferenceSystem(3005),True)
            self.project.addMapLayer(vlayer)
            return ('internal', vlayer)
    # LAYER_VISIBLITY METHOD: Turns on and off layers in a QGIS layer tree so that only specific layers can be mapped/exported
        # INPUTS:   group_on = a list of layer names that will be visible
        #           group_off = a list of layer names that will not be visible
    def layer_visibility(self, group_on, groups_off):
        for fc in groups_off:
            iface.setActiveLayer(fc)
            node = self.tc_root.findLayer(iface.activeLayer().id())
            node.setItemVisibilityChecked(False)
        for fc in group_on:
            iface.setActiveLayer(fc)
            node = self.tc_root.findLayer(iface.activeLayer().id())
            node.setItemVisibilityChecked(True)
    # EXTENT_RECTANGLE METHOD: Identifies the extent of a QGIS vector layer
        # INPUTS:   data1 = a single feature from a vector layer
    def extent_rectangle(self, data1):
        #rectangle = QgsVectorLayer.extent(data1)
        rectangle = data1.geometry().boundingBox()
        rect = [rectangle.xMinimum(), rectangle.yMinimum(), rectangle.xMaximum(), rectangle.yMaximum()]
        exnt_str = "{},{},{},{}".format(rect[0], rect[1], rect[2], rect[3])
        return exnt_str
    def add_field(self, layer, field_name, field_type, att_value):
        layer.startEditing()
        myField = QgsField(field_name, getattr(QVariant, field_type))
        layer.addAttribute( myField )
        idx = layer.fields().indexFromName( field_name )
        for f in layer.getFeatures():
            f[idx] = str(att_value)
            layer.updateFeature( f )
        layer.commitChanges()
    def delete_field(self, layer, field_name):
        idx = layer.fields().indexFromName( field_name )
        if idx != (-1):
            res = layer.dataProvider().deleteAttributes([idx])
            layer.updateFields()


class FNBLine:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'FNBLine_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&FNBLine')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.dlg = FNBLineDialog()



    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('FNBLine', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
 
        icon_path = ':/plugins/FN_BLine/icon.png' #must reload resource file if icon is changed using OSGeo4WShell
        self.add_action(
            icon_path,
            text=self.tr(u'New2Q-Reports'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&FNBLine'),
                action)
            self.iface.removeToolBarIcon(action)

    def select_output_file(self):
        filename = QFileDialog.getSaveFileName(self.dlg, "Select output file ","", '*.txt')
        self.dlg.path_input.setText(filename)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = FNBLineDialog()
        

        con_filename = #~~~~~~~~~~~~~INSERT config.ini FILE PATH AND FILE NAME HERE ~~~~~~~~~~~~~~~~~~~~~
        con_section = #~~~~~~~~~~~~~INSERT config.ini SECTION NAME HERE ~~~~~~~~~~~~~~~~~~~~~
        db_config = config(con_filename, con_section)
    
        #set database connection information in plugin gui from congif.ini file
        self.dlg.database_input.setPlaceholderText(db_config['database'])
        self.dlg.host_input.setPlaceholderText(db_config['host'])
        self.dlg.port_input.setPlaceholderText(db_config['port'])

        # show the dialogdb_config['host']
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            try:
                # get parameters
                iface.mainWindow().blockSignals(True) #turns off CRS dialog box when creating layers
                aoi = self.dlg.path_input.text()
                aoi_wc = self.dlg.query_input.text()
                aoi_name = aoi
                if aoi == '': #grabs loaded qgs vector layer if no path input is given
                    aoi_name = str(self.dlg.vector_input.currentText())
                    for child in QgsProject.instance().layerTreeRoot().children():
                        if child.layer().name() == aoi_name:
                            aoi = child.layer()
                            
                if isinstance(aoi, QgsVectorLayer) is True: # Ends process if AOI is a point or line
                    if aoi.wkbType() == QgsWkbTypes.Point:
                        raise TypeError('Area of Interest cannot be a point geometry')
                    if aoi.wkbType() == QgsWkbTypes.LineString:
                        raise TypeError('Area of Interest cannot be a line geometry')                
                if isinstance(aoi, QgsVectorLayer) is False:# Ends process if AOI is raster or is non existent 
                    if isinstance(aoi, QgsRasterLayer) is True:
                        raise TypeError('Area of Interest cannot be a raster layer')
                    if aoi == '':
                        raise NameError('Area of Interest does not exist')

                database = self.dlg.database_input.text()
                host = self.dlg.host_input.text()
                port = self.dlg.port_input.text()
                user = self.dlg.username_input.text()
                password = self.dlg.password_input.text()
                
                #check the database connection and if there is no input by user, default to config.ini file
                input_list= {'database':database, 'host': host, 'port': port}
                for item in input_list:
                    if input_list[item] == '':
                        input_list[item] = db_config[item]
                database = input_list['database']
                host = input_list['host']
                port = input_list['port']

                pdf_output = self.dlg.pdf_input.text()                
                if pdf_output == '':
                    try:
                        username = os.getenv('username')
                        pdf_output = os.path.join(r'C:\Users\{}\AppData\Local\Temp'.format(username), aoi_name)
                        os.mkdir(pdf_output)
                    except:
                        pdf_output = r'C:\Users\{}\AppData\Local\Temp\PDF_Output'.format(username)
                        if not os.path.exists:
                            os.mkdir(pdf_output)

                #test the database connection by building a BCGW vector layer if it fails script breaks
                test_Oracle_data = 'WHSE_ADMIN_BOUNDARIES.EBC_PROV_ELECTORAL_DIST_SVW'
                test_Oracle_data_geom_col = 'SHAPE'
                test_Oracle_data_unique_col = 'OBJECTID'
                schema,table = test_Oracle_data.split('.')
                uri = QgsDataSourceUri()
                uri.setConnection(host, port, database, user, password)
                uri.setDataSource(schema, table, test_Oracle_data_geom_col)             
                uri.setKeyColumn(test_Oracle_data_unique_col)
                test_connection = QgsVectorLayer(uri.uri(), "LAYER_NAME", 'oracle')
                if test_connection.isValid() is False:
                    QgsMessageLog.logMessage('Database connection error - confirm database, host and port are accurate', 'Messages')
                    sys.exit(1)

                #create o2q object 
                test = o2q(database, host, user, port, password)

                #change project coordinate system to bc albers
                QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(3005))

                #build aoi
                source, aoi_base = test.format_checker(aoi, aoi_wc)
                symbol = QgsFillSymbol.createSimple({'line_style': 'solid', 'color': '255,0,0,0', 'color_border':'#ff0000', 'width_border':'1'})
                aoi_base.renderer().setSymbol(symbol)
                aoi_base.triggerRepaint()
                iface.layerTreeView().refreshLayerSymbology(aoi_base.id())

                #create buffer for arch sites 50m outside of aoi
                buf = test.buffer(aoi_base, 50)
                dif = test.difference(buf, aoi_base)

                # creates dictionary of all fc to compare aoi too
                csv_path #~~~~~~~~~~~~~~~~~~~~~~~INSERT CSV PATH HERE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                fc_dic = parse_csv(csv_path)

                #build objects for html table
                html_counter = 0
                html_dic =  {}
                group_dic =  {}
                obj_list = []
                group_list = []
                for obj in fc_dic: #get all unique group numbers from csv and build it into a list of all numbers
                    dic = (fc_dic[obj])
                    if dic['Grouping'] not in group_list:
                        group_list.append(dic['Grouping'])            
                for group in group_list: #add each group to the html_dic and group_dic
                    groupkey = 'g{}'.format(group)
                    html_dic[groupkey] = {'pg1': 'None'}
                    group_dic[groupkey] = [aoi_base]
                    globals()['makepdf_gr%s' % group] = pdf_maker_QGIS()
                    obj_list.append(globals()['makepdf_gr%s' % group])

                #add aoi to html table by adding field
                text_table = {}
                count = aoi_base.featureCount()
                test.add_field(aoi_base, 'layer', 'String', att_value=aoi_base.name())
                sum_type, sum_num = summation(aoi_base, aoi_base.name(), special = 'aoi')
                for item in obj_list:
                    group_key = [k for k, v in globals().items() if v is item][0][-1]
                    (item).html_combiner(html_dic, html_counter, sum_type, sum_num, group_key, ('AOI: ' + aoi_base.name()), count, text_table)
                html_counter += 1

                #BEGIN INTERSECTIONS
                QgsMessageLog.logMessage('Beginning layer intersection with AOI', 'Messages')
                
                #intersect AOI with layers of interest and produce a breakdown table that will be added to the pdf
                sorted_fc_dic = sorted(fc_dic, key=lambda x: (fc_dic[x]['Grouping']))
                for obj in sorted_fc_dic:
                    dic = (fc_dic[obj])
                    layer_title = (obj)
                    layer_table = dic['Feature_Name']
                    location = dic['Location']
                    layer_sql = dic['Queries']
                    layer_group = dic['Grouping']
                    layer_expansion = dic['Expansion']
                    QgsMessageLog.logMessage('starting on layer:  {}'.format(layer_table), 'Messages') 
                    feature_layer_lst = [] #build empty layer list for each obj to be merged at end of unique feature cycle
                    if source == 'external':
                        for item in aoi_base.getFeatures(): #iterate through each item in aoi
                            aoi_base.select(item.id())
                            if location == 'BCGW':
                                if layer_title == 'Archeological sites within 50m':
                                    selected_features = test.Rect_anyinteract(layer_table, item, layer_title)
                                    result = test.clipper(selected_features, dif, layer_title, selection=True)
                                    feature_layer_lst.append(result)
                                else:
                                    selected_features = test.Rect_anyinteract(layer_table, item, layer_title)
                                    try:
                                        result = test.clipper(selected_features, aoi_base, layer_title, selection=True)
                                    except:
                                        selectedfixed_features = test.fix_geom(selected_features, 'fixed')
                                        result = test.clipper(selectedfixed_features, aoi_base, layer_title, selection=True)
                                    feature_layer_lst.append(result)
                            else:
                                result = external_intersetion(location, layer_table, layer_title, aoi_base, test)
                                feature_layer_lst.append(result)
                            aoi_base.removeSelection()
                        result = test.merger(feature_layer_lst, layer_title)
                    elif source == 'internal':
                        for item in aoi_base.getFeatures():
                            aoi_base.select(item.id())
                            if location == 'BCGW':
                                try:
                                    unique_id = item.attribute('OBJECT_ID')
                                    feature_wc = "OBJECT_ID = {}".format(int(unique_id))
                                except:
                                    unique_id = item.attribute('OBJECTID')
                                    feature_wc = "OBJECTID = {}".format(int(unique_id))
                                if layer_title == 'Archeological sites within 50m':
                                    selected_features = test.select_by_location(layer_table, aoi, layer_sql, feature_wc, 'Intersect', layer_title)
                                    result = test.clipper(selected_features, dif, layer_title, selection=True)
                                    feature_layer_lst.append(result)
                                else:
                                    selected_features = test.select_by_location(layer_table, aoi, layer_sql, feature_wc, 'Intersect', layer_title)
                                    try:
                                        result = test.clipper(selected_features, aoi_base, layer_title, selection=True)
                                    except:
                                        selectedfixed_features = test.fix_geom(selected_features, 'fixed')
                                        result = test.clipper(selectedfixed_features, aoi_base, layer_title, selection=True)
                                    feature_layer_lst.append(result)
                            else:
                                result = external_intersetion(location, layer_table, layer_title, aoi_base, test)                            
                                feature_layer_lst.append(result)
                            aoi_base.removeSelection()
                        result = test.merger(feature_layer_lst, layer_title)
                    if result.crs().authid() != 'EPSG:3005':
                        result = test.reproject(result, layer_title)
                    result.setCrs(QgsCoordinateReferenceSystem(3005),True)
                    test.delete_field(result, 'SE_ANNO_CAD_DATA')
                    # Create the htmls for each groupping and prep for map by making layer list for each group
                    group_name = 'g{}'.format(layer_group)
                    count = result.featureCount()
                    for var in obj_list:
                        if str([k for k, v in globals().items() if v is var][0][-1]) == str(layer_group):
                            item = var
                    if layer_group != 1 and group_dic[group_name] == [aoi_base] and layer_group != fc_dic[sorted_fc_dic[(sorted_fc_dic.index(layer_title)-1)]]['Grouping']: #create new count when moving to next group
                            html_counter = 0
                    if count != 0:
                        if layer_expansion != '':
                            sum_type, sum_num = summation(result, layer_title)
                            (item).html_combiner(html_dic, html_counter, sum_type, sum_num, layer_group, layer_title, count, text_table)
                            html_counter += 1
                            group_dic[group_name].append(result)
                            dic, ls = summation(result, layer_title, field=layer_expansion, special=True)
                            for feature in dic:
                                count = ls.count(feature)
                                sum_num = int(dic[feature][0])
                                sum_type = 'area'
                                acronym = ''
                                for word in obj.split(' '):
                                    acronym = acronym + word[0]
                                layer_tbl_title = '{}: '.format(acronym.upper()) + str(feature)
                                (item).html_combiner(html_dic, html_counter, sum_type, sum_num, layer_group, layer_tbl_title, count, text_table)
                                html_counter += 1
                        else:
                            sum_type, sum_num = summation(result, layer_title)
                            (item).html_combiner(html_dic, html_counter, sum_type, sum_num, layer_group, layer_title, count, text_table)
                            html_counter += 1
                            group_dic[group_name].append(result)
                        QgsProject.instance().addMapLayer(result)
                        result.renderer().symbol().setOpacity(0.30)
                        result.triggerRepaint()
                        iface.layerTreeView().refreshLayerSymbology(result.id())

                #remove unwanter layers
                QgsProject.instance().removeMapLayers([dif.id()])

                #QgsMessageLog.logMessage('building PDFS...', 'Messages')
                iface.messageBar().pushMessage("Status", '   building PDFS, please wait...', level=1, duration=5)

                #export all pdfs
                for group_key in group_list:
                    #group_key = [k for k, v in globals().items() if v is item][0][-1]
                    group_name = 'g{}'.format(group_key)
                    if group_dic[group_name] != [aoi_base]:
                        pdf_name = '_' + aoi_base.name()  + '_' + group_name
                        on, off = choose_vis(group_key, group_dic )
                        list_on = test.layer_visibility(on, off)
                        (item).pdf_creation(aoi_base, pdf_name, html_dic[group_name], pdf_output)

                # zoome to extent of aoi 
                vLayer = iface.setActiveLayer(group_dic[group_name][0])
                vLayer = iface.activeLayer()
                canvas = iface.mapCanvas()
                exnt = build_extent(vLayer)
                canvas.setExtent(exnt)
                iface.mapCanvas().refresh()
                
                # create text delineated table for show more section
                tab = "{}\n\n".format(pdf_output)
                for k, v in text_table.items():
                    area, length, count = v
                    tab = tab + k + ':       ' + '    area = ' + str(area) + '        length = ' + str(length ) + '        feature count = ' + str(count) + '\n'
                    tab = tab + '-'*len(k + ':       ' + '    area = ' + str(area) + '        length = ' + str(length ) + '        feature count = ' + str(count) + '\n') + '\n'
 


                QgsMessageLog.logMessage('Script comeplete', 'Messages')

                iface.mainWindow().blockSignals(False)
                iface.messageBar().pushMessage("Complete", 'View more to see where PDFs are located', tab, level=3, duration=30)
            except Exception as e:
                print(e)
                iface.messageBar().pushMessage('Error', str(e), level=2, duration = 5)
                iface.mainWindow().blockSignals(False)
                if 'dif' in locals():
                    if len(QgsProject.instance().mapLayersByName('50m Buffer')) != 0:
                        QgsProject.instance().removeMapLayers([dif.id()])
                if 'group_dic' in locals():
                    vlayer_list = []
                    for item in group_dic:
                        for i in group_dic[item]:
                            if i not in vlayer_list:
                                vlayer_list.append(i)
                                QgsMessageLog.logMessage(i.name(), 'Messages')            
                    for features in vlayer_list:
                        QgsProject.instance().removeMapLayers([features.id()])
                for child in QgsProject.instance().layerTreeRoot().children():
                    r = child.layer()
                    if isinstance(r, QgsRasterLayer) is True:
                        QgsProject.instance().removeMapLayers([r.id()])

